<!DOCTYPE html>
<html>

<head>
  <title>Force with d3</title>
  <meta charset="UTF-8">
</head>
<style type="text/css">
html,
body {
  padding: 0;
  margin: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
}

canvas {
  width: 100%;
  height: 100%;
}
</style>

<body>
  <button id="center">Center random node</button>
  <button id="run">Run layout</button>
  <button id="pause">Pause layout</button>
  <script type="text/javascript" src="../build/grapher.js"></script>
  <script type="text/javascript" src="https://raw.githubusercontent.com/ayasdi/grapher-center/master/center-min.js"></script>
  <script type="text/javascript" src="https://raw.githubusercontent.com/ayasdi/grapher-target/master/target-min.js"></script>
  <script type="text/javascript" src="https://raw.githubusercontent.com/ayasdi/grapher-zoom/master/zoom-min.js"></script>
  <script type="text/javascript" src="./vendor/d3.js"></script>
  <script type="text/javascript">
  d3
    .json('http://controller02:7574/db/data/transaction/commit')
    .header("Content-Type", "application/json")
    .post(JSON.stringify({
      "statements": [{
        "statement": "start n=node(20455) match p=shortestPath((n)-[*..5]-(o)) return distinct p limit 100",
        "resultDataContents": ["row", "graph"],
        "includeStats": true
      }]
    }), function(msg, data) {
      //console.log('data', data.results[0].data);
      createGraph(data.results[0].data);
    });


  var createGraph = function(relationships) {

    var palette = ['#f0f9e8', '#bae4bc', '#7bccc4', '#43a2ca', '#0868ac'];
    var theme = {
      'Disease': {
        colour: '#FF4F69',
        size: 30
      },
      'Chemical': {
        colour: '#65D35B',
        size: 15
      },
      'Gene': {
        colour: '#6693FF',
        size: 25
      },
      'Chebi': {
        colour: '#75FFB3',
        size: 15
      },
      'GOTerm': {
        colour: '#FFEDFA',
        size: 10
      },
      'COTerm': {
        colour: '#FFEAE1',
        size: 10
      },
      'Pathway': {
        colour: '#694AFF',
        size: 50
      }
    };
    // Generate some data

    var nodeMap = {},
      relMap = {},
      network = {
        nodes: [],
        links: []
      },
      width = window.innerWidth,
      height = window.innerHeight,
      nodeCount = 0;

    for (var i = relationships.length - 1; i >= 0; i--) {
      var graph = relationships[i].graph;

      for (var j = relationships[i].graph.nodes.length - 1; j >= 0; j--) {
        var node = relationships[i].graph.nodes[j];
        if (!nodeMap[node.id]) {
          nodeMap[node.id] = node;
          nodeMap[node.id].grapherIndex = nodeCount;
          nodeCount++;
          network.nodes.push({
            x: Math.random() * width,
            y: Math.random() * height,
            r: theme[nodeMap[node.id].labels[0]].size,
            weight: 1,
            color: theme[nodeMap[node.id].labels[0]].colour
          });
        }
      }

      for (var j = relationships[i].graph.relationships.length - 1; j >= 0; j--) {
        var rel = relationships[i].graph.relationships[j];
        if (!relMap[rel.id]) {
          relMap[rel.id] = rel;
          var from = nodeMap[relMap[rel.id].startNode].grapherIndex,
            to = nodeMap[relMap[rel.id].endNode].grapherIndex;
          network.links.push({
            from: from,
            to: to,
            source: network.nodes[from],
            target: network.nodes[to],
            color: network.nodes[from].color
          });
        }
      }
    }

    // Helper function for offsets.
    function getOffset(e) {
      if (e.offsetX) return {
        x: e.offsetX,
        y: e.offsetY
      };
      var rect = e.target.getBoundingClientRect();
      var x = e.clientX - rect.left,
        y = e.clientY - rect.top;
      return {
        x: x,
        y: y
      };
    }

    // Create a grapher instance (width, height, options)
    var grapher = new Grapher({
      data: network
    });

    // Variable to keep track of the node we're dragging and the current offset
    var dragging = null,
      offset = null,
      panning = null,
      mouseDown = false,
      mouseDownPoint,
      mouseDownDataPoint;

    function onMouseDown(e) {
      mouseDownPoint = getOffset(e);
      mouseDownDataPoint = grapher.getDataPosition(mouseDownPoint);
      mouseDown = true;
      var nodeId = grapher.target(mouseDownDataPoint);
      if (nodeId > -1) {
        dragging = {
          node: network.nodes[nodeId],
          id: nodeId
        };
        offset = mouseDownDataPoint;
      } else {
        mouseDownPoint = getOffset(e);
        panning = true;
        dragging = offset = null;
      }
      grapher.render();
    }

    function onMouseMove(e) {

      if(!mouseDown) {
        return false;
      }

      if (dragging) {
        var eOffset = getOffset(e);
        var point = grapher.getDataPosition(eOffset);
        if (dragging) {
          offset = point;
          force.alpha(1); // restart the force graph
        } else {
          var nodeId = grapher.nearest(point)[0];
        }
        grapher.render();
      } else if (panning) {
          var translate = grapher.translate(),
            dragOffset = getOffset(e);
          translate[0] += (dragOffset.x - mouseDownPoint.x);
          translate[1] += (dragOffset.y - mouseDownPoint.y);
          mouseDownPoint = dragOffset;
          grapher.translate(translate);
      }
    }

    function onMouseUp(e) {
      mouseDown = false;
      if (dragging) {
        dragging = offset = null;
      } else {
        panning = null;
      }
      mouseDownPoint = null;
    }

    // On mousedown, grab the node that was clicked.
    grapher.on('mousedown', onMouseDown);
    grapher.on('mousemove', onMouseMove);
    grapher.on('mouseup', onMouseUp);
    grapher.on('wheel', function(e) {
      var center = getOffset(e);
      var delta = e.deltaY / 2000;
      // Call zoom with the ratio and center.
      grapher.zoom(1 - delta, center);
      // Render the graph
      grapher.render();
    });

    // onTick gets called on each tick of D3's force
    var onTick = function() {
      if (dragging && offset) {
        // update the node's position here so it's sticky
        dragging.node.x = offset.x;
        dragging.node.y = offset.y;
      }
      force.alpha(1);
      grapher.update(); // update the grapher
    };

    // Setup D3's force layout
    var force = d3.layout.force()
      .nodes(network.nodes)
      .links(network.links)
      .size([width, height])
      .on('tick', onTick)
      .charge(-5000)
      .gravity(0.005)
      .linkStrength(0.2)
      .linkDistance(100)
      .friction(0.02)
      .start();

      window.force = force;

    // Append the grapher's view onto the page
    document.body.appendChild(grapher.canvas);

    // Render the graph using play. This will call render in a requestAnimationFrame loop.
    grapher.play();
    // grapher.render();
    window.grapher = grapher;

    d3.select('#center').on('click', function() {
      grapher.center([Math.floor(Math.random() * network.nodes.length)]);
    });
    d3.select('#run').on('click', function() {
      force.start();
      grapher.play();
    });
    d3.select('#pause').on('click', function() {
      force.stop();
      grapher.pause();
    });
  };
  </script>
</body>

</html>
