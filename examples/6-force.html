<!DOCTYPE html>
<html>

<head>
  <title>Force with d3</title>
  <meta charset="UTF-8">
</head>
<style type="text/css">
html,
body {
  padding: 0;
  margin: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
}

canvas {
  width: 100%;
  height: 100%;
}
#status {
    bottom: 0;
    left: 25px;
    position: fixed;
}
#query {
  position: fixed;
  top: 50px;
  left: 25px;
}
#textQuery {
  font-size: 18px;
  min-height: 100px;
  opacity: 0.5;
  padding: 10px;
  width: 100%;
}
.running {
  display: none;
}
.paused {
  display: none;
}
.three-quarters-loader {
    display: block !important;
    margin: 15px auto;
  }
  @-moz-keyframes three-quarters-loader {
    0% {
      -moz-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  @-webkit-keyframes three-quarters-loader {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  @keyframes three-quarters-loader {
    0% {
      -moz-transform: rotate(0deg);
      -ms-transform: rotate(0deg);
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
      -ms-transform: rotate(360deg);
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  /* :not(:required) hides this rule from IE9 and below */
  .three-quarters-loader:not(:required) {
    -moz-animation: three-quarters-loader 1250ms infinite linear;
    -webkit-animation: three-quarters-loader 1250ms infinite linear;
    animation: three-quarters-loader 1250ms infinite linear;
    border: 8px solid #38e;
    border-right-color: transparent;
    border-radius: 16px;
    box-sizing: border-box;
    display: inline-block;
    position: relative;
    overflow: hidden;
    text-indent: -9999px;
    width: 32px;
    height: 32px;
  }
</style>

<body>
  <button id="center">Center random node</button>
  <button id="run">Run layout</button>
  <button id="pause">Pause layout</button>
  <div id="status">
    Layout running...
    <div class="three-quarters-loader"></div>
  </div>
  <form id="query" onsubmit="event.preventDefault(); return executeQuery();">
    <textarea id="textQuery">start n=node(204525) match p=shortestPath((n)-[*..5]-(o)) return distinct p limit 50</textarea>
    <button type="submit">Go</button>
  </form>
  <canvas id="graph"></canvas>
  <script type="text/javascript" src="../build/grapher.js"></script>
  <script type="text/javascript" src="https://raw.githubusercontent.com/ayasdi/grapher-center/master/center-min.js"></script>
  <script type="text/javascript" src="https://raw.githubusercontent.com/ayasdi/grapher-target/master/target-min.js"></script>
  <script type="text/javascript" src="https://raw.githubusercontent.com/ayasdi/grapher-zoom/master/zoom-min.js"></script>
  <script type="text/javascript" src="./vendor/d3.js"></script>
  <script type="text/javascript">

  d3.select('#center').on('click', function() {
    grapher.center([Math.floor(Math.random() * network.nodes.length)]);
    grapher.render();
  });
  d3.select('#run').on('click', function() {
    force.start();
    grapher.play();
    d3.select('#status').style('display', 'block');
  });
  d3.select('#pause').on('click', function() {
    force.stop();
    grapher.pause();
    d3.select('#status').style('display', 'none');
  });

  var executeQuery = function() {
    d3
    .json('http://controller02:7574/db/data/transaction/commit')
    .header("Content-Type", "application/json")
    .post(JSON.stringify({
      "statements": [{
        "statement": document.getElementById("textQuery").value,
        "resultDataContents": ["row", "graph"],
        "includeStats": true
      }]
    }), function(msg, data) {
      createGraph(data.results[0].data);
    });
    return false;
  };

  var clearGraph = function() {
    if(window.grapher) {
      // window.grapher.initialize(window.grapher);
      // var ctx = grapher.canvas.getContext('webgl');
      // ctx.clearRect(0, 0, grapher.canvas.width, grapher.canvas.height);
    }
  };

  var createGraph = function(relationships) {

    clearGraph();

    var palette = ['#f0f9e8', '#bae4bc', '#7bccc4', '#43a2ca', '#0868ac'];
    var theme = {
      'Disease': {
        colour: '#FF4F69',
        size: 30
      },
      'Chemical': {
        colour: '#65D35B',
        size: 15
      },
      'Gene': {
        colour: '#6693FF',
        size: 25
      },
      'Chebi': {
        colour: '#75FFB3',
        size: 15
      },
      'GOTerm': {
        colour: '#FFEDFA',
        size: 10
      },
      'COTerm': {
        colour: '#FFEAE1',
        size: 10
      },
      'Pathway': {
        colour: '#694AFF',
        size: 50
      }
    };
    // Generate some data

    var nodeMap = {},
      relMap = {},
      network = {
        nodes: [],
        links: []
      },
      width = window.innerWidth,
      height = window.innerHeight,
      nodeCount = 0;

    for (var i = relationships.length - 1; i >= 0; i--) {
      var graph = relationships[i].graph;

      for (var j = relationships[i].graph.nodes.length - 1; j >= 0; j--) {
        var node = relationships[i].graph.nodes[j];
        if (!nodeMap[node.id]) {
          var label = node.labels[0];
          nodeMap[node.id] = {
            x: Math.random() * width,
            y: Math.random() * height,
            r: theme[label].size,
            weight: 1,
            color: theme[label].colour,
            grapherIndex: nodeCount
          };
          nodeCount++;
          network.nodes.push(nodeMap[node.id]);
        }
      }

      for (var j = relationships[i].graph.relationships.length - 1; j >= 0; j--) {
        var rel = relationships[i].graph.relationships[j];
        if (!relMap[rel.id]) {
          relMap[rel.id] = rel;
          var from = nodeMap[relMap[rel.id].startNode].grapherIndex,
            to = nodeMap[relMap[rel.id].endNode].grapherIndex;
          network.links.push({
            from: from,
            to: to,
            source: network.nodes[from],
            target: network.nodes[to],
            color: '#EEEEEE'//network.nodes[from].color
          });
        }
      }
    }

    // Helper function for offsets.
    function getOffset(e) {
      if (e.offsetX) return {
        x: e.offsetX,
        y: e.offsetY
      };
      var rect = e.target.getBoundingClientRect();
      var x = e.clientX - rect.left,
        y = e.clientY - rect.top;
      return {
        x: x,
        y: y
      };
    }

    // Create a grapher instance (width, height, options)
    var grapher = new Grapher({
      data: network,
      canvas: document.getElementById('graph')
    });

    // Variable to keep track of the node we're dragging and the current offset
    var dragging = null,
      offset = null,
      panning = null,
      mouseDown = false,
      mouseDownPoint,
      mouseDownDataPoint;

    function onMouseDown(e) {
      mouseDownPoint = getOffset(e);
      mouseDownDataPoint = grapher.getDataPosition(mouseDownPoint);
      mouseDown = true;
      var nodeId = grapher.target(mouseDownDataPoint);
      if (nodeId > -1) {
        dragging = {
          node: network.nodes[nodeId],
          id: nodeId
        };
        offset = mouseDownDataPoint;
      } else {
        mouseDownPoint = getOffset(e);
        panning = true;
        dragging = offset = null;
      }
      grapher.render();
    }

    function onMouseMove(e) {

      var eOffset = getOffset(e);
      var point = grapher.getDataPosition(eOffset);

      if(!mouseDown) {
        // check hovering
        var nodeId = grapher.target(point);
      }

      if (dragging) {
        offset = point;
        force.alpha(1);
        grapher.render();
      } else if (panning) {
        var translate = grapher.translate(), dragOffset = getOffset(e);
        translate[0] += (dragOffset.x - mouseDownPoint.x);
        translate[1] += (dragOffset.y - mouseDownPoint.y);
        mouseDownPoint = dragOffset;
        grapher.translate(translate);
        grapher.render();
      }
    }

    function onMouseUp(e) {
      mouseDown = false;
      if (dragging) {
        dragging = offset = null;
      } else {
        panning = null;
      }
      mouseDownPoint = null;
    }

    // On mousedown, grab the node that was clicked.
    grapher.on('mousedown', onMouseDown);
    grapher.on('mousemove', onMouseMove);
    grapher.on('mouseup', onMouseUp);
    grapher.on('wheel', function(e) {
      var center = getOffset(e);
      var delta = e.deltaY / 2000;
      // Call zoom with the ratio and center.
      grapher.zoom(1 - delta, center);
      // Render the graph
      grapher.render();
    });

    // onTick gets called on each tick of D3's force
    var onTick = function() {
      if (dragging && offset) {
        // update the node's position here so it's sticky
        dragging.node.x = offset.x;
        dragging.node.y = offset.y;
      }
      force.alpha(1);
      grapher.update(); // update the grapher
    };

    // Setup D3's force layout
    var force = d3.layout.force()
      .nodes(network.nodes)
      .links(network.links)
      .size([width, height])
      .on('tick', onTick)
      .charge(-10000)
      .gravity(0.005)
      .linkStrength(0.2)
      .linkDistance(100)
      .friction(0.02)
      .start();

      window.force = force;

    // Append the grapher's view onto the page
    document.body.appendChild(grapher.canvas);

    // Render the graph using play. This will call render in a requestAnimationFrame loop.
    grapher.play();
    // grapher.render();
    window.grapher = grapher;

    return false;
  };

  </script>
</body>

</html>
